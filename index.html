<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¥æœ¬èªãƒ«ãƒ“æŒ¯ã‚Šå›</title>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #212529;
            --accent-color: #007bff;
            --accent-hover-color: #0056b3;
            --accent-disabled-color: #00b2ff;
            --border-color: #dee2e6;
            --output-bg-color: #ffffff;
            --output-text-color: #343a40;
            --ruby-color: #495057;
            --card-shadow: 0 6px 12px rgba(0,0,0,0.1);
            --button-bg: var(--accent-color);
            --button-text: #ffffff;
            --button-secondary-bg: #6c757d;
            --button-secondary-hover-bg: #5a6268;
            --button-danger-bg: #dc3545;
            --button-danger-hover-bg: #c82333;
            --highlight-bg: rgba(0, 123, 255, 0.1);
            --speaking-paragraph-bg: rgba(255, 224, 178, 0.3); /* More subtle paragraph highlight */
            --speaking-sentence-bg: #ffe0b2; /* Orange tint for speaking sentence */
            --speaking-text-color: #000; /* Text color for speaking highlights */
            --slider-thumb-bg: var(--accent-color);
            --slider-track-bg: #ccc;
        }

        .dark-mode {
            --bg-color: #121212;
            --text-color: #e0e0e0;
            --accent-color: #00aaff;
            --accent-hover-color: #0077cc;
            --accent-disabled-color: #0077cc;
            --border-color: #444444;
            --output-bg-color: #1e1e1e;
            --output-text-color: #f0f0f0;
            --ruby-color: #bbbbbb;
            --card-shadow: 0 6px 16px rgba(0,0,0,0.4);
            --button-secondary-bg: #555c63;
            --button-secondary-hover-bg: #43484e;
            --button-danger-bg: #a71d2a;
            --button-danger-hover-bg: #841721;
            --highlight-bg: rgba(0, 170, 255, 0.15);
            --speaking-paragraph-bg: rgba(90, 62, 30, 0.4);
            --speaking-sentence-bg: #5a3e1e;
            --speaking-text-color: #f0f0f0;
            --slider-thumb-bg: var(--accent-color);
            --slider-track-bg: #555;
        }

        body {
            font-family: 'Hiragino Kaku Gothic ProN', 'Meiryo', Meiryo, Osaka, 'MS PGothic', 'MS PGothic', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.8;
            font-size: 16px;
            transition: background-color 0.3s, color 0.3s;
        }

        .container {
            max-width: 950px;
            margin: 20px auto; /* Added top/bottom margin */
            padding: 30px;
            background-color: var(--output-bg-color);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            transition: background-color 0.3s;
        }

        h1, h2, h3 {
            color: var(--accent-color);
            text-align: center;
            margin-bottom: 25px;
        }
        h1 { font-size: 2.4em; letter-spacing: 0.5px;} /* Slightly adjusted */
        h2 { font-size: 1.7em; margin-top: 30px; border-bottom: 2px solid var(--border-color); padding-bottom: 15px;}
        h3 { font-size: 1.3em; text-align: left; margin-top: 25px; margin-bottom: 15px;}

        textarea {
            width: calc(100% - 28px);
            min-height: 180px;
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 1.05em;
            margin-bottom: 5px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s, box-shadow 0.3s;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.25);
        }
        .dark-mode textarea:focus { box-shadow: 0 0 0 3px rgba(0,170,255,0.3); }

        .main-controls, .sub-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 25px;
            align-items: center;
        }

        .control-group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        .control-group label { font-size: 0.95em; margin-right: 5px; }
        .control-group input[type="range"] { width: 100px; cursor: pointer; accent-color: var(--accent-color);}


        button, select {
            padding: 10px 18px;
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            transition: background-color 0.2s ease-in-out, transform 0.1s ease;
            font-weight: 500;
            min-width: 80px;
            text-align: center;
            display: inline-flex; 
            align-items: center;
            justify-content: center;
        }
        select {
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 10px 12px;
            min-width: 180px;
        }

        button:hover, select:hover {
            background-color: var(--accent-hover-color);
            color: var(--button-text);
        }
        select:hover { border-color: var(--accent-hover-color); background-color: var(--bg-color); }
        button:active { transform: scale(0.97); }

        button:disabled, select:disabled {
            background-color: #cccccc; border-color: #cccccc; color: #666666;
            cursor: not-allowed; opacity: 0.7; transform: scale(1);
        }
        .dark-mode button:disabled, .dark-mode select:disabled {
            background-color: #4a4a4a; border-color: #4a4a4a; color: #888888;
        }

        button.secondary { background-color: var(--button-secondary-bg); }
        button.secondary:hover { background-color: var(--button-secondary-hover-bg); }
        button.danger { background-color: var(--button-danger-bg); }
        button.danger:hover { background-color: var(--button-danger-hover-bg); }

        .icon-button { font-size: 1.3em; padding: 8px 12px; min-width: auto; }
        .theme-toggle-button { margin-left: auto; }

        .output-container {
            margin-top: 30px; padding: 25px; border: 1px solid var(--border-color);
            border-radius: 8px; background-color: var(--bg-color);
            transition: background-color 0.3s, color 0.3s, border-color 0.3s;
        }
        
        .ruby-text p {
            margin-bottom: 1.8em; font-size: 1.2em; line-height: 3;
            color: var(--output-text-color); padding: 8px; border-radius: 4px;
            transition: background-color 0.3s, color 0.3s, box-shadow 0.2s;
            -webkit-line-break: anywhere; line-break: anywhere; word-break: break-all;
        }
        .ruby-text p.speaking-paragraph {
            background-color: var(--speaking-paragraph-bg); /* Subtle highlight for whole paragraph */
            /* box-shadow: 0 0 8px var(--speaking-paragraph-bg); */
        }
        .ruby-text span.sentence {
            transition: background-color 0.2s, color 0.2s;
            border-radius: 3px; /* For sentence highlight visibility */
            padding: 0.05em 0.1em; /* Slight padding for sentence highlight */
            margin: -0.05em -0.1em; /* Counteract padding to maintain flow */
        }
        .ruby-text span.sentence.speaking-sentence {
            background-color: var(--speaking-sentence-bg);
            color: var(--speaking-text-color);
            /* box-shadow: 0 0 5px var(--speaking-sentence-bg); */
        }
        .ruby-text span.sentence.speaking-sentence ruby rt { /* Ensure ruby text is also visible */
             color: var(--speaking-text-color) !important; /* Important to override default rt color */
             opacity: 0.85;
        }


        ruby {
            ruby-position: over; cursor: help; transition: background-color 0.2s;
            padding: 0.1em 0.05em; border-radius: 3px;
        }
        ruby:hover { background-color: var(--highlight-bg); }
        rt {
            font-size: 0.55em; color: var(--ruby-color); opacity: 0.95;
            font-weight: normal; user-select: none; transition: color 0.3s, opacity 0.3s;
        }
        
        .tts-controls, .extra-features, .audio-export-info {
            margin-top: 20px; padding: 20px; border: 1px solid var(--border-color);
            border-radius: 8px; background-color: var(--output-bg-color);
        }
        .tts-controls .control-group, .extra-features .control-group { margin-bottom: 15px; }
        .tts-controls .control-group:last-child, .extra-features .control-group:last-child { margin-bottom: 0; }

        .slider-container { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; }
        .slider-container label { min-width: 50px; font-size:0.9em; }
        .slider-container input[type="range"] { 
            flex-grow: 1; height: 8px; -webkit-appearance: none; appearance: none; 
            background: var(--slider-track-bg); border-radius: 5px; outline: none;
        }
        .slider-container input[type="range"]::-webkit-slider-thumb { 
            -webkit-appearance: none; appearance: none; width: 18px; height: 18px; 
            background: var(--slider-thumb-bg); border-radius: 50%; cursor: pointer; 
            box-shadow: 0 0 2px rgba(0,0,0,0.2); 
        }
        .slider-container input[type="range"]::-moz-range-thumb { 
            width: 18px; height: 18px; background: var(--slider-thumb-bg); 
            border-radius: 50%; cursor: pointer; border:none; box-shadow: 0 0 2px rgba(0,0,0,0.2);
        }
        .slider-container span { min-width: 30px; text-align: right; font-size: 0.9em; color: var(--text-color);}

        .status-bar {
            font-size: 0.85em; color: var(--text-color); opacity: 0.7;
            margin-top: 0px; margin-bottom: 15px; text-align: right; min-height: 20px; 
        }

        footer { text-align: center; margin-top: 40px; padding-bottom: 20px; font-size: 0.9em; color: #888; }
        .dark-mode footer { color: #bbb; }

        @media print {
            body { padding: 0; font-size: 12pt; color: #000 !important; background-color: #fff !important; }
            .container, .output-container, .ruby-text p, .ruby-text span.sentence {
                background-color: #fff !important;
                color: #000 !important;
                box-shadow: none !important;
                border: none !important;
            }
            .main-controls, .sub-controls, .tts-controls, .extra-features, .audio-export-info, .theme-toggle-button, footer, h1, h3,
            textarea, .status-bar, #loadSampleButton, #sampleTextSelector, #clearButton, .font-controls, #toggleRubyButton,
            .tts-actions button, .tts-settings, .extra-features button, #resetSettingsButton, #printOutputButton {
                display: none !important;
            }
            h2 { text-align: left; border-bottom: 1px solid #ccc; font-size: 1.5em; }
            .output-container { padding: 0; margin: 0; }
            .ruby-text p { margin-bottom: 1em; line-height: 2.5; font-size: 1em !important; } /* Ensure font size is not from JS variable for print */
            rt { font-size: 0.6em !important; color: #333 !important; }
            .hide-ruby-rt rt { display: none !important; } /* Respect ruby visibility for print */
        }

        @media (max-width: 768px) {
            body { padding: 15px;}
            .container { padding: 20px;}
            .main-controls, .sub-controls { flex-direction: column; align-items: stretch;}
            .control-group { justify-content: space-between; }
            .control-group label { margin-right: 10px;}
            .theme-toggle-button { margin-left: 0; width: 100%; margin-top:10px;}
            
            .tts-controls .control-group, .extra-features .control-group { flex-direction: column; align-items: stretch;}
            .tts-controls .control-group button, .extra-features .control-group button,
            .tts-controls .control-group select, .extra-features .control-group select,
            .sub-controls button { width: 100%; margin-bottom: 8px; }
            .tts-controls .control-group button:last-child, .extra-features .control-group button:last-child,
            .sub-controls button:last-child { margin-bottom: 0;}
            
            .slider-container { flex-direction: column; align-items: stretch;}
            .slider-container label { margin-bottom: 5px; text-align: left; }
            .slider-container span { text-align: left; margin-top: 5px;}
            .slider-container input[type="range"] { width: auto; }
        }
        @media (max-width: 600px) {
            body { padding: 10px; font-size:15px; }
            .container { padding: 15px; }
            h1 { font-size: 2em; }
            textarea { min-height: 150px;}
            .ruby-text p { font-size: 1.1em; line-height: 2.8;}
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>æ—¥æœ¬èªãƒ«ãƒ“æŒ¯ã‚Šå› <span style="font-size: 0.6em; color: var(--accent-disabled-color);">(è¶…å¼·åŒ–ãƒ»æ©Ÿèƒ½è¿½åŠ ç‰ˆ)</span></h1>
        <p>ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚¨ãƒªã‚¢ã«æ–‡ç« ã‚’å…¥åŠ›ã¾ãŸã¯è²¼ã‚Šä»˜ã‘ã€ã€Œæ¼¢å­—ï¼ˆã‹ã‚“ã˜ï¼‰ã€ã®å½¢å¼ã§ãƒ«ãƒ“ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚</p>
        
        <textarea id="inputText" rows="12" placeholder="ä¾‹: æ­¤å‡¦ï¼ˆã“ã“ï¼‰ã«æ—¥æœ¬èªï¼ˆã«ã»ã‚“ã”ï¼‰ã®æ–‡ç« ï¼ˆã¶ã‚“ã—ã‚‡ã†ï¼‰ã‚’å…¥åŠ›ï¼ˆã«ã‚…ã†ã‚Šã‚‡ãï¼‰ã—ã¦ãã ã•ã„ã€‚" aria-label="æ—¥æœ¬èªå…¥åŠ›ã‚¨ãƒªã‚¢"></textarea>
        <div id="statusBar" class="status-bar" aria-live="polite"></div>

        <div class="main-controls">
            <div class="control-group">
                <button id="loadSampleButton" title="ä¾‹æ–‡ã‚’èª­ã¿è¾¼ã‚€">ä¾‹æ–‡</button>
                <select id="sampleTextSelector" aria-label="ä¾‹æ–‡ã‚’é¸æŠ"></select>
                <button id="clearButton" class="secondary" title="å…¥åŠ›å†…å®¹ã‚’æ¶ˆå»">ã‚¯ãƒªã‚¢</button>
            </div>
            <div class="control-group font-controls">
                <button id="decreaseFontButton" class="icon-button" title="æ–‡å­—ã‚’å°ã•ã" aria-label="æ–‡å­—ã‚’å°ã•ã">ãƒ¼</button>
                <button id="increaseFontButton" class="icon-button" title="æ–‡å­—ã‚’å¤§ãã" aria-label="æ–‡å­—ã‚’å¤§ãã">ï¼‹</button>
            </div>
            <div class="control-group">
                <button id="toggleRubyButton" title="ãƒ«ãƒ“è¡¨ç¤ºåˆ‡æ›¿">ãƒ«ãƒ“ OFF</button>
            </div>
             <div class="control-group">
                <button id="themeToggleButton" class="icon-button theme-toggle-button" title="ãƒ†ãƒ¼ãƒåˆ‡æ›¿" aria-label="ãƒ†ãƒ¼ãƒã‚’åˆ‡ã‚Šæ›¿ãˆã‚‹">ğŸŒ™</button>
            </div>
        </div>
        
        <div class="sub-controls">
             <div class="control-group">
                <button id="resetSettingsButton" class="secondary" title="å…¨ã¦ã®è¨­å®šã‚’åˆæœŸåŒ–"><span role="img" aria-label="ãƒªã‚»ãƒƒãƒˆ">ğŸ”„</span> è¨­å®šãƒªã‚»ãƒƒãƒˆ</button>
                <button id="printOutputButton" class="secondary" title="è¡¨ç¤ºçµæœã‚’å°åˆ·"><span role="img" aria-label="å°åˆ·">ğŸ–¨ï¸</span> çµæœã‚’å°åˆ·</button>
            </div>
        </div>


        <div class="tts-controls">
            <h3><span role="img" aria-label="ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³">ğŸ”Š</span> éŸ³å£°æœ—èª­</h3>
            <div class="control-group">
                <label for="voiceSelect">å£°ã®é¸æŠ:</label>
                <select id="voiceSelect" aria-label="å£°ã‚’é¸æŠ"></select>
            </div>
            <div class="control-group tts-actions">
                <button id="playButton" title="å†ç”Ÿ"><span role="img" aria-label="å†ç”Ÿ">â–¶ï¸</span> å†ç”Ÿ</button>
                <button id="pauseButton" title="ä¸€æ™‚åœæ­¢" disabled><span role="img" aria-label="ä¸€æ™‚åœæ­¢">â¸ï¸</span> ä¸€æ™‚åœæ­¢</button>
                <button id="resumeButton" title="å†ç”Ÿå†é–‹" disabled><span role="img" aria-label="å†é–‹">â¯ï¸</span> å†é–‹</button>
                <button id="stopButton" class="danger" title="åœæ­¢" disabled><span role="img" aria-label="åœæ­¢">â¹ï¸</span> åœæ­¢</button>
            </div>
            <div class="control-group tts-settings">
                 <div class="slider-container">
                    <label for="rateSlider">é€Ÿã•:</label>
                    <input type="range" id="rateSlider" min="0.5" max="2" step="0.1" value="1" aria-label="èª­ã¿ä¸Šã’é€Ÿåº¦">
                    <span id="rateValue" aria-hidden="true">1.0</span>
                </div>
                <div class="slider-container">
                    <label for="pitchSlider">é«˜ã•:</label>
                    <input type="range" id="pitchSlider" min="0" max="2" step="0.1" value="1" aria-label="èª­ã¿ä¸Šã’ã®é«˜ã•">
                    <span id="pitchValue" aria-hidden="true">1.0</span>
                </div>
            </div>
        </div>
        
        <div class="audio-export-info">
            <h3><span role="img" aria-label="æƒ…å ±ã‚¢ã‚¤ã‚³ãƒ³">â„¹ï¸</span> éŸ³å£°ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã«ã¤ã„ã¦</h3>
            <p style="font-size:0.9em;">
                ç¾åœ¨ã€ã‚¦ã‚§ãƒ–ãƒ–ãƒ©ã‚¦ã‚¶ã®æ¨™æº–æ©Ÿèƒ½ï¼ˆWeb Speech APIï¼‰ã§ã¯ã€åˆæˆã•ã‚ŒãŸéŸ³å£°ã‚’ç›´æ¥ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã™ã‚‹æ©Ÿèƒ½ã¯æä¾›ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚
                ã“ã‚Œã¯ã€éŸ³å£°åˆæˆãŒãƒ–ãƒ©ã‚¦ã‚¶ã‚„ã‚ªãƒšãƒ¬ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ ã®æ©Ÿèƒ½ã«ä¾å­˜ã—ã¦è¡Œã‚ã‚Œã‚‹ãŸã‚ã€ã‚¦ã‚§ãƒ–ãƒšãƒ¼ã‚¸å´ã§éŸ³å£°ãƒ‡ãƒ¼ã‚¿ãã®ã‚‚ã®ã«ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã“ã¨ãŒåˆ¶é™ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚
            </p>
            <p style="font-size:0.9em;">
                æœ—èª­ã•ã‚ŒãŸéŸ³å£°ã‚’ä¿å­˜ã—ãŸã„å ´åˆã¯ã€ãŠæ‰‹æ•°ã§ã™ãŒã€ãŠä½¿ã„ã®ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿ã«æ­è¼‰ã•ã‚Œã¦ã„ã‚‹éŸ³å£°éŒ²éŸ³ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚’ã”åˆ©ç”¨ãã ã•ã„ã€‚
            </p>
            <ul style="font-size:0.85em;">
                <li><strong>Windows:</strong> ã€Œãƒœã‚¤ã‚¹ãƒ¬ã‚³ãƒ¼ãƒ€ãƒ¼ã€ã‚¢ãƒ—ãƒªãªã©</li>
                <li><strong>macOS:</strong> ã€ŒQuickTime Playerã€ã®ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåéŒ²æ©Ÿèƒ½ã€ã€Œãƒœã‚¤ã‚¹ãƒ¡ãƒ¢ã€ã‚¢ãƒ—ãƒªãªã©</li>
                <li><strong>Linux:</strong> ã€ŒAudacityã€ã‚„å„ç¨®ãƒ‡ã‚£ã‚¹ãƒˆãƒªãƒ“ãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³æ¨™æº–ã®ã‚µã‚¦ãƒ³ãƒ‰ãƒ¬ã‚³ãƒ¼ãƒ€ãƒ¼ãªã©</li>
            </ul>
            <p style="font-size:0.9em;">ã“ã‚Œã‚‰ã®ãƒ„ãƒ¼ãƒ«ã§ã‚³ãƒ³ãƒ”ãƒ¥ãƒ¼ã‚¿å†…éƒ¨ã®éŸ³ï¼ˆã‚¹ãƒ†ãƒ¬ã‚ªãƒŸã‚­ã‚µãƒ¼ã‚„ãƒ«ãƒ¼ãƒ—ãƒãƒƒã‚¯å‡ºåŠ›ï¼‰ã‚’éŒ²éŸ³ã™ã‚‹ã“ã¨ã§ã€éŸ³å£°ã‚’ãƒ•ã‚¡ã‚¤ãƒ«ã¨ã—ã¦ä¿å­˜ã§ãã¾ã™ï¼ˆè¨­å®šãŒå¿…è¦ãªå ´åˆãŒã‚ã‚Šã¾ã™ï¼‰ã€‚</p>
        </div>

        <div class="extra-features">
            <h3><span role="img" aria-label="å·¥å…·ã‚¢ã‚¤ã‚³ãƒ³">ğŸ› ï¸</span> ä¾¿åˆ©æ©Ÿèƒ½</h3>
            <div class="control-group">
                <button id="copyHtmlButton" title="ãƒ«ãƒ“ä»˜ãHTMLã‚’ã‚³ãƒ”ãƒ¼"><span role="img" aria-label="ã‚³ãƒ”ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³">ğŸ“‹</span> HTMLã‚³ãƒ”ãƒ¼</button>
                <button id="copyTextButton" title="è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ”ãƒ¼ï¼ˆãƒ«ãƒ“ã¯æ‹¬å¼§ä»˜ãï¼‰"><span role="img" aria-label="ã‚³ãƒ”ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³">ğŸ“„</span> ãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ”ãƒ¼</button>
                <button id="copyCleanTextButton" title="ãƒ«ãƒ“ãªã—å…ƒãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚³ãƒ”ãƒ¼ (èª­ã¿ä¸Šã’ç”¨)"><span role="img" aria-label="ã‚³ãƒ”ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³">ğŸ§¹</span> å…ƒãƒ†ã‚­ã‚¹ãƒˆã‚³ãƒ”ãƒ¼</button>
            </div>
        </div>

        <div class="output-container">
            <h2><span role="img" aria-label="æ›¸é¡ã‚¢ã‚¤ã‚³ãƒ³">ğŸ“„</span> è¡¨ç¤ºçµæœ</h2>
            <div id="outputArea" class="ruby-text" aria-live="polite">
                <p style="color: #888;">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</p>
            </div>
        </div>
    </div>

    <footer>
        <p>&copy; <span id="currentYear"></span> æ—¥æœ¬èªãƒ«ãƒ“æŒ¯ã‚Šå›</p>
    </footer>

    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        const inputText = document.getElementById('inputText');
        const outputArea = document.getElementById('outputArea');
        const loadSampleButton = document.getElementById('loadSampleButton');
        const sampleTextSelector = document.getElementById('sampleTextSelector');
        const clearButton = document.getElementById('clearButton');
        const increaseFontButton = document.getElementById('increaseFontButton');
        const decreaseFontButton = document.getElementById('decreaseFontButton');
        const themeToggleButton = document.getElementById('themeToggleButton');
        const toggleRubyButton = document.getElementById('toggleRubyButton');
        const statusBar = document.getElementById('statusBar');
        const resetSettingsButton = document.getElementById('resetSettingsButton');
        const printOutputButton = document.getElementById('printOutputButton');


        const voiceSelect = document.getElementById('voiceSelect');
        const playButton = document.getElementById('playButton');
        const pauseButton = document.getElementById('pauseButton');
        const resumeButton = document.getElementById('resumeButton');
        const stopButton = document.getElementById('stopButton');
        const rateSlider = document.getElementById('rateSlider');
        const rateValue = document.getElementById('rateValue');
        const pitchSlider = document.getElementById('pitchSlider');
        const pitchValue = document.getElementById('pitchValue');

        const copyHtmlButton = document.getElementById('copyHtmlButton');
        const copyTextButton = document.getElementById('copyTextButton');
        const copyCleanTextButton = document.getElementById('copyCleanTextButton');

        let currentFontSize = 1.2; // em
        const FONT_STEP = 0.1;
        const DEFAULT_FONT_SIZE = 1.2;
        let japaneseVoices = [];
        let synthesis = window.speechSynthesis;
        let utteranceQueue = [];
        let currentUtteranceIndex = 0;
        let currentParagraphElements = []; 
        let isPaused = false;
        let isRubyVisible = true;
        const DEFAULT_RUBY_VISIBLE = true;

        // Sentence delimiter regex: captures sequences ending with standard terminators or newlines.
        // It tries to keep the delimiter with the sentence.
        const SENTENCE_DELIMITER_REGEX = /[^ã€‚ï¼ï¼Ÿ\n]+[ã€‚ï¼ï¼Ÿ\n]?|\n+/g;


        const sampleTexts = [
            { name: "æ¨™æº–çš„ãªä¾‹æ–‡", text: `ãã‚Œå…‰é™°ï¼ˆã“ã†ã„ã‚“ï¼‰ãŸã‚‹ã‚„ã€è›ï¼ˆã»ãŸã‚‹ï¼‰ã®å¾®å…‰ï¼ˆã³ã“ã†ï¼‰ã®å¦‚ï¼ˆã”ã¨ï¼‰ãã€ç™½é§’ï¼ˆã¯ã£ãï¼‰ã®éš™ï¼ˆã’ãï¼‰ã‚’éï¼ˆã™ï¼‰ãã‚‹ãŒå¦‚ï¼ˆã”ã¨ï¼‰ã—ã€‚ãã®è¥ï¼ˆã²ã ï¼‰ã®é–“ï¼ˆã‚ã„ã ï¼‰ã«ã¯ã€ä¸‡åƒï¼ˆã°ã‚“ã›ã‚“ï¼‰ã®å¹½éŸµï¼ˆã‚†ã†ã„ã‚“ï¼‰ã‚’è”µï¼ˆãã†ï¼‰ã—ã€è©©ï¼ˆã—ï¼‰ã®å¦‚ï¼ˆã”ã¨ï¼‰ãç”»ï¼ˆãˆï¼‰ã®å¦‚ï¼ˆã”ã¨ï¼‰ãã€äººï¼ˆã²ã¨ï¼‰ã®éæ€ï¼ˆã‹ã—ï¼‰ã‚’èª˜ï¼ˆã•ãï¼‰ã†ã€‚\næ™¨ç†¹ï¼ˆã—ã‚“ãï¼‰åˆï¼ˆã¯ã˜ï¼‰ã‚ã¦éœ²ï¼ˆã‚ã‚‰ï¼‰ã‚ã‚Œã€é‡‘çƒï¼ˆãã‚“ã†ï¼‰é›²ï¼ˆãã‚‚ï¼‰ã‚’ç ´ï¼ˆã‚„ã¶ï¼‰ã‚‹ã€‚å…‰ï¼ˆã²ã‹ã‚Šï¼‰ã¯ç¶ºçª“ï¼ˆããã†ï¼‰ã‚’é€ï¼ˆã¨ãŠï¼‰ã—ã€å®¤ï¼ˆã—ã¤ï¼‰ã‚’æ˜ ï¼ˆã†ã¤ï¼‰ã—ã¦è¼ï¼ˆã‹ãŒã‚„ï¼‰ãã‚’ç”Ÿï¼ˆã—ã‚‡ã†ï¼‰ã˜ã€ç¹Šå¡µï¼ˆã›ã‚“ã˜ã‚“ï¼‰ç¿©è·¹ï¼ˆã¸ã‚“ã›ã‚“ï¼‰ã¨ã—ã¦ã€ä»™å¨¥ï¼ˆã›ã‚“ãŒï¼‰ã®èˆï¼ˆã¾ï¼‰ã„èµ·ï¼ˆãŸï¼‰ã¤ãŒè‹¥ï¼ˆã”ã¨ï¼‰ã—ã€‚`},
            { name: "çŸ­ã„æŒ¨æ‹¶", text: `ä»Šæ—¥ï¼ˆãã‚‡ã†ï¼‰ã¯å¤©æ°—ï¼ˆã¦ã‚“ãï¼‰ãŒã„ã„ã§ã™ã­ã€‚æ˜æ—¥ï¼ˆã‚ã—ãŸï¼‰ã‚‚æ™´ï¼ˆã¯ï¼‰ã‚Œã‚‹ã¨ã„ã„ãªã€‚`},
            { name: "è¤‡é›‘ãªå˜èª", text: `æ†‚é¬±ï¼ˆã‚†ã†ã†ã¤ï¼‰ãªæ°—åˆ†ï¼ˆãã¶ã‚“ï¼‰ã‚’æ‰•æ‹­ï¼ˆãµã£ã—ã‚‡ãï¼‰ã™ã‚‹ãŸã‚ã«ã€çˆç²ï¼ˆã‚³ãƒ¼ãƒ’ãƒ¼ï¼‰ã‚’é£²ï¼ˆã®ï¼‰ã‚“ã ã€‚è–”è–‡ï¼ˆã°ã‚‰ï¼‰ãŒç¶ºéº—ï¼ˆãã‚Œã„ï¼‰ã ã€‚`},
            { name: "ã²ã‚‰ãŒãªã‚«ã‚¿ã‚«ãƒŠæ··ã˜ã‚Š", text: `ã“ã‚Œã¯å¹³ä»®åï¼ˆã²ã‚‰ãŒãªï¼‰ã¨ç‰‡ä»®åï¼ˆã‚«ã‚¿ã‚«ãƒŠï¼‰ã®ãƒ†ã‚¹ãƒˆã§ã™ã€‚æª¸æª¬ï¼ˆãƒ¬ãƒ¢ãƒ³ï¼‰ã¯é…¸ï¼ˆã™ï¼‰ã£ã±ã„ã€‚`},
            { name: "è‹±èªã¨ãƒ«ãƒ“", text: `ã“ã‚Œã¯Testï¼ˆãƒ†ã‚¹ãƒˆï¼‰ã§ã™ã€‚Appleï¼ˆã‚¢ãƒƒãƒ—ãƒ«ï¼‰ç¤¾ã€‚` },
            { name: "æ‹¬å¼§ã®èª¤ç”¨ä¾‹", text: `ã“ã®æ–‡ã«ã¯ï¼ˆæ­£ã—ã„ï¼‰ãƒ«ãƒ“ã¨ã€ï¼ˆãŸã ã®æ‹¬å¼§ï¼‰ã¨ã€æ¼¢å­—ï¼ˆã‹ã‚“ã˜ï¼‰ã˜ã‚ƒãªã„ã‚‚ã®ï¼ˆã²ã‚‰ãŒãªï¼‰ã«ãƒ«ãƒ“ã‚’æŒ¯ã‚ã†ã¨ã™ã‚‹è©¦ã¿ãŒã‚ã‚Šã¾ã™ã€‚ABCï¼ˆã‚¨ãƒ¼ãƒ“ãƒ¼ã‚·ãƒ¼ï¼‰ã€‚ï¼ˆã‹ã£ã“ï¼‰ã ã‘ã€‚` }
        ];

        function escapeHtml(unsafe) {
            if (typeof unsafe !== 'string') return '';
            return unsafe
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
        }
        
        function parseRubyText(text) {
            let result = '';
            let remainingText = text;
            const rubyPattern = /((?:[ä¸€-é¾¯ã€…ã€†ãƒµãƒ¶]+)|(?:[a-zA-Z0-9]+))ï¼ˆ([ã-ã‚“ã‚¡-ãƒ¶ãƒ¼]+?)ï¼‰/g;
            let lastIndex = 0;
            let match;

            while ((match = rubyPattern.exec(remainingText)) !== null) {
                result += escapeHtml(remainingText.substring(lastIndex, match.index));
                const base = match[1];
                const ruby = match[2];
                const isKanjiBase = /[ä¸€-é¾¯ã€…ã€†ãƒµãƒ¶]/.test(base);
                const isAlphaNumBase = /^[a-zA-Z0-9]+$/.test(base);
                const isValidFurigana = /^[ã-ã‚“ã‚¡-ãƒ¶ãƒ¼]+$/.test(ruby);

                if ((isKanjiBase || isAlphaNumBase) && isValidFurigana) {
                    result += `<ruby>${escapeHtml(base)}<rt>${escapeHtml(ruby)}</rt></ruby>`;
                } else {
                    result += escapeHtml(match[0]);
                }
                lastIndex = rubyPattern.lastIndex;
            }
            result += escapeHtml(remainingText.substring(lastIndex));
            return result;
        }

        function renderText(text) {
            const paragraphsInput = text.split(/\n/); 
            let paragraphCount = 0;
            
            outputArea.innerHTML = paragraphsInput.map((pContent, pIndex) => {
                const trimmedPContent = pContent.trim();
                const pElement = document.createElement('p');
                pElement.style.fontSize = `${currentFontSize}em`;
                pElement.dataset.paragraphId = pIndex; 

                if (trimmedPContent === '') {
                    pElement.innerHTML = '<br>';
                    pElement.style.minHeight = '1em';
                } else {
                    paragraphCount++;
                    const sentenceStrings = trimmedPContent.match(SENTENCE_DELIMITER_REGEX) || [trimmedPContent];
                    let sentencesHTML = "";
                    sentenceStrings.forEach((sentenceStr, sIndex) => {
                        if (sentenceStr.trim() !== '') {
                            const sentenceRubyHTML = parseRubyText(sentenceStr); 
                            sentencesHTML += `<span class="sentence" data-sentence-id="${pIndex}-${sIndex}">${sentenceRubyHTML}</span>`;
                        }
                    });
                    pElement.innerHTML = sentencesHTML;
                }
                return pElement.outerHTML;
            }).join('');

            if (text.trim() === '') {
                outputArea.innerHTML = `<p style="color: #888; font-size: ${currentFontSize}em;">ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...</p>`;
            }
            
            updateCharacterCount(text);

            if (synthesis.speaking || synthesis.pending || synthesis.paused) {
                stopSpeech(true); 
            }
        }
        
        function updateCharacterCount(text) {
            const charCount = text.length;
            const kanjiCount = (text.match(/[ä¸€-é¾¯ã€…ã€†ãƒµãƒ¶]/g) || []).length;
            const sentences = text.match(SENTENCE_DELIMITER_REGEX);
            const sentenceCount = sentences ? sentences.filter(s => s.trim() !== '').length : 0;
            statusBar.textContent = `æ–‡å­—æ•°: ${charCount} | æ¼¢å­—æ•°: ${kanjiCount} | æ–‡æ•°: ${sentenceCount}`;
        }

        function getCleanTextForSpeech(element) {
            let text = '';
            const childNodes = element.childNodes;

            for (let i = 0; i < childNodes.length; i++) {
                const node = childNodes[i];
                if (node.nodeType === Node.TEXT_NODE) {
                    text += node.textContent;
                } else if (node.nodeName === 'RUBY') {
                    if (node.childNodes.length > 0 && node.childNodes[0].nodeType === Node.TEXT_NODE) {
                        text += node.childNodes[0].textContent;
                    } else if (node.childNodes.length > 0 && node.childNodes[0].childNodes.length > 0 && node.childNodes[0].childNodes[0].nodeType === Node.TEXT_NODE){
                        text += node.childNodes[0].childNodes[0].textContent;
                    }
                } else if (node.nodeName === 'BR') {
                     text += '\n'; 
                } else if (node.childNodes && node.childNodes.length > 0) {
                    if (node.classList && node.classList.contains('sentence')) { // If it's a sentence span, recurse
                         text += getCleanTextForSpeech(node);
                    } else if (node.nodeName !== "RT") { // Avoid RT content generally, unless it's part of a sentence structure
                         text += getCleanTextForSpeech(node); 
                    }
                }
            }
            // For character index mapping, it's crucial that the text generated here for the utterance
            // closely matches how the `onboundary` event's charIndex will be calculated.
            // Usually, multiple spaces are collapsed to one by the speech engine.
            return text.replace(/\s+/g, ' ').trim(); 
        }

        function populateVoiceList() {
            if (typeof speechSynthesis === 'undefined') {
                playButton.disabled = true; voiceSelect.disabled = true;
                const option = document.createElement('option'); option.textContent = 'éŸ³å£°åˆæˆã¯ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“';
                voiceSelect.appendChild(option); console.warn("Speech Synthesis not supported.");
                [rateSlider, pitchSlider, pauseButton, resumeButton, stopButton].forEach(el => el.disabled = true); return;
            }
            const loadVoices = () => {
                japaneseVoices = synthesis.getVoices().filter(voice => voice.lang.startsWith('ja'));
                voiceSelect.innerHTML = ''; 
                if (japaneseVoices.length === 0) {
                    const option = document.createElement('option'); option.textContent = 'åˆ©ç”¨å¯èƒ½ãªæ—¥æœ¬èªã®éŸ³å£°ãŒã‚ã‚Šã¾ã›ã‚“';
                    voiceSelect.appendChild(option); playButton.disabled = true; return;
                }
                playButton.disabled = false; let persistedVoiceName = localStorage.getItem('preferredVoice'); let voiceFound = false;
                japaneseVoices.forEach(voice => {
                    const option = document.createElement('option'); option.textContent = `${voice.name} (${voice.lang})`;
                    option.setAttribute('data-lang', voice.lang); option.setAttribute('data-name', voice.name);
                    if (voice.name === persistedVoiceName) { option.selected = true; voiceFound = true; }
                    voiceSelect.appendChild(option);
                });
                if (!voiceFound && japaneseVoices.length > 0) { 
                     voiceSelect.options[0].selected = true;
                     localStorage.setItem('preferredVoice', voiceSelect.options[0].getAttribute('data-name'));
                }
            };
            synthesis.onvoiceschanged = loadVoices;
            if (synthesis.getVoices().length > 0) loadVoices();
        }
        
        voiceSelect.addEventListener('change', () => {
            localStorage.setItem('preferredVoice', voiceSelect.selectedOptions[0]?.getAttribute('data-name'));
        });

        function playNextUtterance() {
            if (currentUtteranceIndex < utteranceQueue.length && !isPaused) {
                const {utterance, paragraphElement, sentenceData} = utteranceQueue[currentUtteranceIndex];
                
                document.querySelectorAll('.ruby-text span.sentence.speaking-sentence').forEach(s => s.classList.remove('speaking-sentence'));
                currentParagraphElements.forEach(p => p.classList.remove('speaking-paragraph'));
                if (paragraphElement) paragraphElement.classList.add('speaking-paragraph');

                utterance.onboundary = (event) => {
                    if (paragraphElement) {
                        paragraphElement.querySelectorAll('span.sentence.speaking-sentence').forEach(s => s.classList.remove('speaking-sentence'));
                    }
                    
                    const charIndex = event.charIndex;
                    for (const sentence of sentenceData) {
                        if (charIndex >= sentence.rangeStart && charIndex < sentence.rangeEnd) {
                            sentence.element.classList.add('speaking-sentence');
                            sentence.element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                            break; 
                        }
                    }
                };

                utterance.onend = () => {
                    if (paragraphElement) {
                        paragraphElement.classList.remove('speaking-paragraph');
                        paragraphElement.querySelectorAll('span.sentence.speaking-sentence').forEach(s => s.classList.remove('speaking-sentence'));
                    }
                    currentUtteranceIndex++;
                    if (!isPaused) { 
                        playNextUtterance();
                    }
                };
                
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance error:', event);
                    if (paragraphElement) {
                         paragraphElement.classList.remove('speaking-paragraph');
                         paragraphElement.querySelectorAll('span.sentence.speaking-sentence').forEach(s => s.classList.remove('speaking-sentence'));
                    }
                    updateTTSButtons(false, false); 
                    alert(`éŸ³å£°å†ç”Ÿã‚¨ãƒ©ãƒ¼: ${event.error || 'ä¸æ˜ãªã‚¨ãƒ©ãƒ¼'}`);
                };

                synthesis.speak(utterance);
            } else {
                if (currentUtteranceIndex >= utteranceQueue.length) { 
                    console.log("All utterances finished.");
                }
                document.querySelectorAll('.ruby-text p.speaking-paragraph').forEach(p => p.classList.remove('speaking-paragraph'));
                document.querySelectorAll('.ruby-text span.sentence.speaking-sentence').forEach(s => s.classList.remove('speaking-sentence'));
                updateTTSButtons(false, false); 
                isPaused = false; 
            }
        }

        function startSpeech() {
            if (synthesis.speaking) synthesis.cancel();
            
            isPaused = false;
            currentParagraphElements = Array.from(outputArea.querySelectorAll('p[data-paragraph-id]')); 
            utteranceQueue = [];
            currentUtteranceIndex = 0;

            const selectedVoiceName = voiceSelect.selectedOptions[0]?.getAttribute('data-name');
            const voice = japaneseVoices.find(v => v.name === selectedVoiceName);

            if (!voice) { alert('æœ‰åŠ¹ãªæ—¥æœ¬èªã®éŸ³å£°ã‚’é¸æŠã—ã¦ãã ã•ã„ã€‚'); updateTTSButtons(false, false); return; }

            currentParagraphElements.forEach(pElem => {
                const cleanParagraphText = getCleanTextForSpeech(pElem);
                if (!cleanParagraphText) return; 

                const utterance = new SpeechSynthesisUtterance(cleanParagraphText);
                utterance.voice = voice; utterance.lang = voice.lang;
                utterance.rate = parseFloat(rateSlider.value); utterance.pitch = parseFloat(pitchSlider.value);
                
                const sentenceSpans = Array.from(pElem.querySelectorAll('span.sentence'));
                let charOffset = 0;
                const sentenceDataForTTS = sentenceSpans.map(span => {
                    const cleanSentenceText = getCleanTextForSpeech(span);
                    const start = charOffset;
                    charOffset += cleanSentenceText.length;
                    // Check if a space should be added to the offset if sentences were implicitly joined by one.
                    if (charOffset < cleanParagraphText.length && cleanParagraphText.charAt(charOffset) === ' ' && !cleanSentenceText.endsWith(' ')) {
                         charOffset++; 
                    }
                    return { element: span, text: cleanSentenceText, rangeStart: start, rangeEnd: charOffset };
                });
                utteranceQueue.push({utterance: utterance, paragraphElement: pElem, sentenceData: sentenceDataForTTS});
            });

            if (utteranceQueue.length > 0) {
                updateTTSButtons(true, false);
                playNextUtterance();
            } else {
                alert('æœ—èª­ã™ã‚‹å†…å®¹ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
                updateTTSButtons(false, false);
            }
        }

        function pauseSpeech() {
            if (synthesis.speaking && !synthesis.paused) {
                synthesis.pause(); isPaused = true; updateTTSButtons(true, true);
            }
        }

        function resumeSpeech() {
            if (synthesis.paused) {
                synthesis.resume(); isPaused = false; updateTTSButtons(true, false);
            }
        }
        
        function stopSpeech(quiet = false) {
            if (synthesis.speaking || synthesis.pending || synthesis.paused) synthesis.cancel();
            document.querySelectorAll('.ruby-text p.speaking-paragraph').forEach(p => p.classList.remove('speaking-paragraph'));
            document.querySelectorAll('.ruby-text span.sentence.speaking-sentence').forEach(s => s.classList.remove('speaking-sentence'));
            utteranceQueue = []; currentUtteranceIndex = 0; isPaused = false;
            if (!quiet) updateTTSButtons(false, false);
        }

        function updateTTSButtons(speaking, pausedState) {
            playButton.disabled = speaking && !pausedState;
            pauseButton.disabled = !speaking || pausedState;
            resumeButton.disabled = !speaking || !pausedState;
            stopButton.disabled = !speaking && !pausedState; 
            rateSlider.disabled = speaking; pitchSlider.disabled = speaking; voiceSelect.disabled = speaking;
        }

        let inputDebounceTimer;
        inputText.addEventListener('input', () => {
            clearTimeout(inputDebounceTimer);
            inputDebounceTimer = setTimeout(() => {
                 renderText(inputText.value);
                 localStorage.setItem('inputText', inputText.value);
            }, 250); 
        });

        sampleTextSelector.addEventListener('change', (e) => {
            const selectedSample = sampleTexts.find(sample => sample.name === e.target.value);
            if (selectedSample) {
                inputText.value = selectedSample.text; renderText(selectedSample.text);
                localStorage.setItem('inputText', selectedSample.text);
            }
        });
        loadSampleButton.addEventListener('click', () => { 
            const selectedSampleName = sampleTextSelector.value;
            const selectedSample = sampleTexts.find(sample => sample.name === selectedSampleName) || sampleTexts[0];
            if (selectedSample) {
                inputText.value = selectedSample.text; sampleTextSelector.value = selectedSample.name; 
                renderText(selectedSample.text); localStorage.setItem('inputText', selectedSample.text);
            }
        });
        clearButton.addEventListener('click', () => {
            inputText.value = ''; renderText(''); 
            localStorage.removeItem('inputText'); updateCharacterCount('');
        });

        increaseFontButton.addEventListener('click', () => {
            currentFontSize = Math.min(3, currentFontSize + FONT_STEP); 
            document.querySelectorAll('.ruby-text p').forEach(el => el.style.fontSize = `${currentFontSize}em`);
            localStorage.setItem('fontSize', currentFontSize.toString());
        });
        decreaseFontButton.addEventListener('click', () => {
            currentFontSize = Math.max(0.5, currentFontSize - FONT_STEP); 
            document.querySelectorAll('.ruby-text p').forEach(el => el.style.fontSize = `${currentFontSize}em`);
            localStorage.setItem('fontSize', currentFontSize.toString());
        });
        
        function applyTheme(isDark) {
             if (isDark) {
                document.body.classList.add('dark-mode'); themeToggleButton.textContent = 'â˜€ï¸';
                themeToggleButton.setAttribute('aria-label', 'ãƒ©ã‚¤ãƒˆãƒ†ãƒ¼ãƒã«åˆ‡ã‚Šæ›¿ãˆã‚‹');
            } else {
                document.body.classList.remove('dark-mode'); themeToggleButton.textContent = 'ğŸŒ™';
                themeToggleButton.setAttribute('aria-label', 'ãƒ€ãƒ¼ã‚¯ãƒ†ãƒ¼ãƒã«åˆ‡ã‚Šæ›¿ãˆã‚‹');
            }
        }
        themeToggleButton.addEventListener('click', () => {
            const isDark = !document.body.classList.contains('dark-mode');
            applyTheme(isDark); localStorage.setItem('theme', isDark ? 'dark' : 'light');
        });

        toggleRubyButton.addEventListener('click', () => {
            isRubyVisible = !isRubyVisible;
            outputArea.classList.toggle('hide-ruby-rt', !isRubyVisible);
            toggleRubyButton.textContent = isRubyVisible ? "ãƒ«ãƒ“ OFF" : "ãƒ«ãƒ“ ON";
            toggleRubyButton.title = isRubyVisible ? "ãƒ«ãƒ“ã‚’éè¡¨ç¤ºã«ã™ã‚‹" : "ãƒ«ãƒ“ã‚’è¡¨ç¤ºã™ã‚‹";
            localStorage.setItem('rubyVisible', isRubyVisible.toString());
        });

        playButton.addEventListener('click', startSpeech);
        pauseButton.addEventListener('click', pauseSpeech);
        resumeButton.addEventListener('click', resumeSpeech);
        stopButton.addEventListener('click', stopSpeech);

        rateSlider.addEventListener('input', () => {
            rateValue.textContent = parseFloat(rateSlider.value).toFixed(1);
            localStorage.setItem('ttsRate', rateSlider.value);
        });
        pitchSlider.addEventListener('input', () => {
            pitchValue.textContent = parseFloat(pitchSlider.value).toFixed(1);
            localStorage.setItem('ttsPitch', pitchSlider.value);
        });

        async function copyToClipboard(text, type) {
            try {
                await navigator.clipboard.writeText(text);
                alert(`${type}ã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚`);
            } catch (err) {
                console.error(`${type}ã‚³ãƒ”ãƒ¼å¤±æ•—:`, err);
                alert(`${type}ã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚`);
            }
        }
        copyHtmlButton.addEventListener('click', () => copyToClipboard(outputArea.innerHTML, 'ãƒ«ãƒ“ä»˜ãHTML'));
        copyTextButton.addEventListener('click', () => { 
            let textToCopy = "";
            outputArea.querySelectorAll('p[data-paragraph-id]').forEach(pElem => {
                if (pElem.querySelector('br') && pElem.textContent.trim() === '') { textToCopy += "\n"; return; }
                let currentPText = "";
                pElem.childNodes.forEach(node => { 
                    if (node.nodeType === Node.TEXT_NODE) { currentPText += node.textContent; }
                    else if (node.nodeName === "SPAN" && node.classList.contains("sentence")) {
                         node.childNodes.forEach(innerNode => { 
                            if (innerNode.nodeType === Node.TEXT_NODE) { currentPText += innerNode.textContent; }
                            else if (innerNode.nodeName === 'RUBY') {
                                currentPText += innerNode.childNodes[0].textContent; 
                                if (isRubyVisible && innerNode.childNodes[1] && innerNode.childNodes[1].nodeName === 'RT') {
                                   currentPText += `ï¼ˆ${innerNode.childNodes[1].textContent}ï¼‰`;
                                }
                            } else if (innerNode.nodeName === 'BR') { currentPText += "\n"; }
                         });
                    } else if (node.nodeName === 'RUBY') { 
                        currentPText += node.childNodes[0].textContent; 
                        if (isRubyVisible && node.childNodes[1] && node.childNodes[1].nodeName === 'RT') {
                           currentPText += `ï¼ˆ${node.childNodes[1].textContent}ï¼‰`;
                        }
                    } else if (node.nodeName === 'BR') { currentPText += "\n"; }
                });
                textToCopy += currentPText.trim() + "\n";
            });
            copyToClipboard(textToCopy.trim(), 'è¡¨ç¤ºãƒ†ã‚­ã‚¹ãƒˆ');
        });
        copyCleanTextButton.addEventListener('click', () => {
             let textToCopy = "";
             outputArea.querySelectorAll('p[data-paragraph-id]').forEach(pElem => {
                if (pElem.querySelector('br') && pElem.textContent.trim() === '') { textToCopy += "\n"; return; }
                if (pElem.textContent.trim() === 'ã“ã“ã«çµæœãŒè¡¨ç¤ºã•ã‚Œã¾ã™...') return;
                textToCopy += getCleanTextForSpeech(pElem) + "\n";
             });
             copyToClipboard(textToCopy.trim(), 'ãƒ«ãƒ“ãªã—å…ƒãƒ†ã‚­ã‚¹ãƒˆ');
        });

        resetSettingsButton.addEventListener('click', () => {
            if (confirm("ã™ã¹ã¦ã®è¨­å®šï¼ˆãƒ†ãƒ¼ãƒã€ãƒ•ã‚©ãƒ³ãƒˆã‚µã‚¤ã‚ºã€éŸ³å£°è¨­å®šã€ãƒ«ãƒ“è¡¨ç¤ºã€å…¥åŠ›å±¥æ­´ï¼‰ã‚’åˆæœŸçŠ¶æ…‹ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ")) {
                localStorage.removeItem('theme');
                localStorage.removeItem('fontSize');
                localStorage.removeItem('rubyVisible');
                localStorage.removeItem('ttsRate');
                localStorage.removeItem('ttsPitch');
                localStorage.removeItem('preferredVoice');
                localStorage.removeItem('inputText'); 
                
                currentFontSize = DEFAULT_FONT_SIZE;
                isRubyVisible = DEFAULT_RUBY_VISIBLE;
                
                applyTheme(false); 
                document.querySelectorAll('.ruby-text p').forEach(el => el.style.fontSize = `${currentFontSize}em`);
                outputArea.classList.toggle('hide-ruby-rt', !isRubyVisible);
                toggleRubyButton.textContent = isRubyVisible ? "ãƒ«ãƒ“ OFF" : "ãƒ«ãƒ“ ON";
                rateSlider.value = 1; rateValue.textContent = "1.0";
                pitchSlider.value = 1; pitchValue.textContent = "1.0";
                
                populateVoiceList(); 
                inputText.value = sampleTexts[0] ? sampleTexts[0].text : ''; 
                renderText(inputText.value);
                alert("è¨­å®šãŒãƒªã‚»ãƒƒãƒˆã•ã‚Œã¾ã—ãŸã€‚");
            }
        });

        printOutputButton.addEventListener('click', () => {
            window.print();
        });

        function initialize() {
            const preferredTheme = localStorage.getItem('theme');
            applyTheme(preferredTheme === 'dark');

            const savedFontSize = localStorage.getItem('fontSize');
            currentFontSize = savedFontSize ? parseFloat(savedFontSize) : DEFAULT_FONT_SIZE;
            
            const savedRubyVisible = localStorage.getItem('rubyVisible');
            isRubyVisible = (savedRubyVisible !== null) ? (savedRubyVisible === 'true') : DEFAULT_RUBY_VISIBLE;
            
            outputArea.classList.toggle('hide-ruby-rt', !isRubyVisible);
            toggleRubyButton.textContent = isRubyVisible ? "ãƒ«ãƒ“ OFF" : "ãƒ«ãƒ“ ON";
            toggleRubyButton.title = isRubyVisible ? "ãƒ«ãƒ“ã‚’éè¡¨ç¤ºã«ã™ã‚‹" : "ãƒ«ãƒ“ã‚’è¡¨ç¤ºã™ã‚‹";
            
            const savedRate = localStorage.getItem('ttsRate');
            if (savedRate) { rateSlider.value = savedRate; rateValue.textContent = parseFloat(savedRate).toFixed(1); }
            const savedPitch = localStorage.getItem('ttsPitch');
            if (savedPitch) { pitchSlider.value = savedPitch; pitchValue.textContent = parseFloat(savedPitch).toFixed(1); }
            
            sampleTexts.forEach(sample => {
                const option = document.createElement('option');
                option.value = sample.name; option.textContent = sample.name;
                sampleTextSelector.appendChild(option);
            });
            if (sampleTexts.length > 0) sampleTextSelector.value = sampleTexts[0].name;

            const savedInput = localStorage.getItem('inputText');
            if (savedInput) inputText.value = savedInput;
            else if (sampleTexts.length > 0) {
                inputText.value = sampleTexts[0].text;
                sampleTextSelector.value = sampleTexts[0].name;
            }
            
            populateVoiceList(); 
            renderText(inputText.value || ''); 
            updateTTSButtons(false, false); 

            window.addEventListener('beforeunload', () => {
                if (synthesis && (synthesis.speaking || synthesis.paused)) synthesis.cancel();
            });
        }
        
        const styleSheet = document.createElement("style");
        styleSheet.innerText = ".hide-ruby-rt rt { display: none !important; }";
        document.head.appendChild(styleSheet);

        initialize();
    </script>
</body>
</html>